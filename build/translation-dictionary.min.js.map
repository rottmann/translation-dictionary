{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///translation-dictionary.min.js","webpack:///webpack/bootstrap 1edc99986bde6a99212c","webpack:///./index.js","webpack:///./lib/translation-dictionary.js","webpack:///./~/eventemitter3/index.js","webpack:///./~/inherits/inherits_browser.js","webpack:///./~/sprintf-js/src/sprintf.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","EventEmitter","EventEmitter3","inherits","sprintf","vsprintf","Number","isInteger","value","isFinite","Math","floor","Array","isArray","args","Object","prototype","toString","DEFAULT_LOCALE","DEFAULT_NPLURALS","DEFAULT_PLURALIZER","TranslationDictionary","baseLocale","baseNPlurals","cache","dict","locale","nPlurals","pluralizers","_createDictionary","getLocale","registerPluralizer","pluralizer","emit","registerTranslation","translations","text","setBaseLocale","setLocale","Error","translate","_translate","arguments","__","translatePlural","_p","withPlural","hash","JSON","stringify","params","number","index","bnp","length","slice","count","_pluralize","dictText","localeIndex","emmit","EE","fn","context","once","_events","undefined","listeners","event","i","l","ee","a1","a2","a3","a4","a5","len","removeListener","apply","j","on","listener","push","events","removeAllListeners","off","addListener","setMaxListeners","EventEmitter2","create","ctor","superCtor","super_","constructor","enumerable","writable","configurable","TempCtor","window","key","hasOwnProperty","parse","format","get_type","variable","toLowerCase","str_repeat","input","multiplier","join","re","not_string","modulo","placeholder","key_access","index_access","sign","parse_tree","argv","arg","k","match","pad","pad_character","pad_length","cursor","tree_length","node_type","output","is_positive","test","isNaN","TypeError","String","fromCharCode","parseInt","toExponential","parseFloat","toFixed","substring","toUpperCase","replace","charAt","fmt","_fmt","arg_names","exec","SyntaxError","field_list","replacement_field","field_match","_argv","splice"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TranslationDictionary\"] = factory();\n\telse\n\t\troot[\"TranslationDictionary\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TranslationDictionary\"] = factory();\n\telse\n\t\troot[\"TranslationDictionary\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(1)\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*global WITHOUT_EVENTS*/\n\t'use strict';\n\t\n\tif (true)\n\t    var EventEmitter = __webpack_require__(2).EventEmitter3;\n\tif (true)\n\t    var inherits     = __webpack_require__(3);\n\tvar sprintf      = __webpack_require__(4).sprintf;\n\tvar vsprintf     = __webpack_require__(4).vsprintf;\n\t\n\t/**\n\t * Polyfill\n\t */\n\tif ( ! Number.isInteger)\n\t    Number.isInteger = function(value) {\n\t        return typeof value === 'number' &&\n\t            isFinite(value) &&\n\t            value > -9007199254740992 &&\n\t            value < 9007199254740992 &&\n\t            Math.floor(value) === value;\n\t    };\n\t\n\tif ( ! Array.isArray)\n\t    Array.isArray = function(args) {\n\t        return Object.prototype.toString.call(args) === '[object Array]';\n\t    };\n\t\n\t/**\n\t * Defaults\n\t */\n\tvar DEFAULT_LOCALE = 'en';\n\tvar DEFAULT_NPLURALS = 2;\n\tvar DEFAULT_PLURALIZER = 1;\n\t\n\t/**\n\t * TranslationDictionary\n\t *\n\t * @fires changeBaseLocale (locale)               Emitted after baseLocale changed.\n\t * @fires changeLocale (locale)                   Emitted after locale changed.\n\t * @fires changeTranslation (locale)              Emitted after translation of the current locale changed.\n\t * @fires missingPluralTranslation (text, locale) Emitted when the plural text is not found in translation.\n\t * @fires missingTranslation (text, locale)       Emitted when the text is not found in translation.\n\t * @fires registerPluralizer (locale, pluralizer) Emitted after a new pluralizer was registered.\n\t * @fires registerTranslation (locale)            Emitted after a new translation was registered.\n\t */\n\tvar TranslationDictionary = function() {\n\t    this.baseLocale = DEFAULT_LOCALE;\n\t    this.baseNPlurals = DEFAULT_NPLURALS;\n\t    this.cache = {}; // cache for current locale\n\t    this.dict = {};\n\t    this.locale = DEFAULT_LOCALE;\n\t    this.nPlurals = {};\n\t    this.pluralizers = {};\n\t    this._createDictionary(this.baseLocale);\n\t};\n\t\n\tif (true)\n\t    inherits(TranslationDictionary, EventEmitter);\n\t\n\t/**\n\t * Get the current locale (default: 'en')\n\t *\n\t * @return {string}\n\t */\n\tTranslationDictionary.prototype.getLocale = function() {\n\t    return this.locale;\n\t};\n\t\n\t/**\n\t * Set a pluralizer for a locale with number of plurals\n\t *\n\t * @param {string}       locale       The locale for which to register the pluralizer.\n\t * @param {callback|int} pluralizer   A callback(number) that returns the index of the plural in dict[text].\n\t * @param {int}          [nPlurals=2] Number of plurals the language has.\n\t */\n\tTranslationDictionary.prototype.registerPluralizer = function(locale, pluralizer, nPlurals) {\n\t    this.pluralizers[locale] = pluralizer;\n\t    this.nPlurals[locale] = nPlurals || DEFAULT_NPLURALS;\n\t    this.cache = {};\n\t    this.emit('registerPluralizer', locale, pluralizer);\n\t};\n\t\n\t/**\n\t * Merge translations to a locale\n\t *\n\t * @param {string} locale       The locale for which to register the translation.\n\t * @param {object} translations An Object with the base locale text as key and the translation as value.\n\t *        {\n\t *            'wolve' : 'vlk',\n\t *            'wolves': [ // nPlurals for Czech is 3\n\t *               'vlci',\n\t *               'vlků'\n\t *           ]\n\t *         }\n\t */\n\tTranslationDictionary.prototype.registerTranslation = function(locale, translations) {\n\t    this._createDictionary(locale);\n\t\n\t    // extend / overwrite dict entries\n\t    for (var text in translations) /*jshint -W089 */\n\t        this.dict[locale][text] = translations[text];\n\t\n\t    this.emit('registerTranslation', locale);\n\t\n\t    // emit when translation of the current locale changed\n\t    if (locale === this.locale && locale !== this.baseLocale)\n\t        this.emit('changeTranslation', locale);\n\t};\n\t\n\t/**\n\t * Set the applications base language\n\t * \n\t * @param {string} locale   Applications base locale.\n\t * @param {int}    nPlurals Number of plurals the base locale has.\n\t */\n\tTranslationDictionary.prototype.setBaseLocale = function(locale, nPlurals) {\n\t    this.baseLocale = locale;\n\t    this.baseNPlurals = nPlurals || DEFAULT_NPLURALS;\n\t    this._createDictionary(locale); // ensure that an empty dictionary for the locale exists\n\t    this.emit('changeBaseLocale', locale);\n\t};\n\t\n\t/**\n\t * Set the current locale\n\t * \n\t * @param {string} locale The locale registered before with registerTranslation / application base locale.\n\t */\n\tTranslationDictionary.prototype.setLocale = function(locale) {\n\t    if (locale === this.locale)\n\t        return;\n\t    if ( ! this.dict[locale])\n\t        throw new Error('[dict] setLocale is called for an unregistered translation');\n\t\n\t    this.locale = locale;\n\t    this.cache = {};\n\t    this.emit('changeLocale', locale);\n\t};\n\t\n\t/**\n\t * Translate a singular text\n\t * \n\t * @param {string} arguments[0]   The text to translate.\n\t * @param {mixed}  [arguments[n]] Optional parameters for sprintf to replace markers in the text.\n\t *        Depending on the markers a list of parameters, an array, or an object can be used.\n\t *        translate('a text');\n\t *        translate('a text %s %s', 'str1', 'str2');\n\t *        translate('a text %s %s', [ 'str1', 'str2' ]);\n\t *        translate('a text %(name)s', { name: 'John Doe' });\n\t * \n\t * @return {string} Translated text.\n\t */\n\tTranslationDictionary.prototype.translate = function(/*arguments*/) {\n\t    return this._translate(arguments);\n\t};\n\t\n\t/**\n\t * Alias for translate()\n\t */\n\tTranslationDictionary.prototype.__ = function(/*arguments*/) {\n\t    return this._translate(arguments);\n\t};\n\t\n\t\n\t/**\n\t * Translate a text as singular or plural, depending on the count\n\t * \n\t * @param {string} arguments[0]               The singular text to translate.\n\t * @param {string} arguments[1..(nPlurals-1)] The plural text to translate.\n\t * @param {mixed}  arguments[nPlurals..n]     The count and parameters for sprintf to replace markers in the text.\n\t *        Depending on the markers a list of parameters, an array, or an object can be used.\n\t *        translatePlural('a text', 'some text', 47);\n\t *        translatePlural('a text %d %s', 'some text %d %s', 47, 'str1');\n\t *        translatePlural('a text %d %s', 'some text %d %s', [ 47, 'str1' ]);\n\t *        translatePlural('a text %(name)s', 'some text %(name)s', { count: 47, name: 'John Doe' });\n\t * \n\t * @return {string} Translated text.\n\t */\n\tTranslationDictionary.prototype.translatePlural = function(/*arguments*/) {\n\t    return this._translate(arguments, true);\n\t};\n\t\n\t/**\n\t * Alias for translatePlural()\n\t */\n\tTranslationDictionary.prototype._p = function(/*arguments*/) {\n\t    return this._translate(arguments, true);\n\t};\n\t\n\t/**\n\t * Translation function called from translate() and translatePlural()\n\t * \n\t * @param  {mixed}   args       Arguments from the calling functions.\n\t * @param  {boolean} withPlural With plural detection.\n\t * @return {string} Translated text.\n\t */\n\tTranslationDictionary.prototype._translate = function(args, withPlural) {\n\t    // cache\n\t    var hash = JSON.stringify(arguments);\n\t    if (hash in this.cache)\n\t        return this.cache[hash];\n\t\n\t    var index = 0;\n\t    var params; // int / array / object\n\t    var bnp = this.baseNPlurals;\n\t    var number;\n\t\n\t    if (withPlural) {\n\t        if (args.length >= bnp) {\n\t            if (typeof args[bnp - 1] !== 'string')\n\t                throw new Error('[dict] parameter ' + bnp + ' for plural must be a string for \\'' + args[0] + '\\'');\n\t\n\t            params = (args.length > (bnp + 1)) ? Array.prototype.slice.call(args, bnp) : args[bnp];\n\t\n\t            if (Number.isInteger(params))\n\t                number = params;\n\t            else {\n\t                if (Array.isArray(params)) {\n\t                    if ( ! params[0])\n\t                        throw new Error('[dict] parameter array is empty for \\'' + args[0] + '\\'');\n\t                    number = params[0];\n\t                }\n\t                else if (typeof params === 'object') {\n\t                    if ( ! params.count)\n\t                        throw new Error('[dict] numeric object.count is missing for \\'' + args[0] + '\\'');\n\t                    number = params.count;\n\t                }\n\t                if ( ! Number.isInteger(number))\n\t                    throw new Error('[dict] numeric value is missing for \\'' + args[0] + '\\'');\n\t            }\n\t\n\t            index = this._pluralize(this.baseLocale, number);\n\t        } else {\n\t            throw new Error('[dict] plural string and numeric value are missing for \\'' + args[0] + '\\'');\n\t        }\n\t    }\n\t    else {\n\t        params = (args.length > bnp) ? Array.prototype.slice.call(args, (bnp - 1)) : args[(bnp - 1)];\n\t    }\n\t\n\t    var text = args[index];\n\t    if (this.locale !== this.baseLocale) {\n\t        var dictText = this.dict[this.locale][text];\n\t        if (dictText)\n\t            if (typeof dictText === 'string') {\n\t                text = dictText;\n\t            } else {\n\t                var localeIndex = this._pluralize(this.locale, number);\n\t                if (dictText.length >= localeIndex)\n\t                    text = dictText[localeIndex - 1];\n\t                else\n\t                    this.emit('missingPluralTranslation', text, this.locale);\n\t            }\n\t        else\n\t            this.emit('missingTranslation', text, this.locale);\n\t    }\n\t\n\t    if (typeof params !== 'undefined')\n\t        if (Array.isArray(params))\n\t            text = vsprintf(text, params);\n\t        else\n\t            text = sprintf(text, params);\n\t\n\t    this.cache[hash] = text;\n\t    return text;\n\t};\n\t\n\t/**\n\t * Create a dictionary if not exists for a locale\n\t * Set default pluralizer and clear the cache.\n\t * \n\t * @param  {string} locale The locale.\n\t */\n\tTranslationDictionary.prototype._createDictionary = function(locale) {\n\t    if ( ! this.dict[locale])\n\t        this.dict[locale] = {};\n\t\n\t    if ( ! this.pluralizers[locale])\n\t        this.registerPluralizer(locale, DEFAULT_PLURALIZER);\n\t\n\t    this.cache = {};\n\t};\n\t\n\t/**\n\t * Execute the pluralizer\n\t * \n\t * @param  {string} locale The locale for which the pluralizer should be used.\n\t * @param  {int}    number The number to check and get the plural index.\n\t * @return {int} Index of the plural form in dict[text].\n\t */\n\tTranslationDictionary.prototype._pluralize = function(locale, number) {\n\t    var pluralizer = this.pluralizers[locale];\n\t    if (typeof pluralizer === 'function')\n\t        return pluralizer.call(this, number);\n\t    else\n\t        return number !== pluralizer ? 1 : 0;\n\t};\n\t\n\tif (true)\n\t    TranslationDictionary.prototype.emmit = function() { };\n\t\n\tmodule.exports = TranslationDictionary;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Representation of a single EventEmitter function.\n\t *\n\t * @param {Function} fn Event handler to be called.\n\t * @param {Mixed} context Context for function execution.\n\t * @param {Boolean} once Only emit once\n\t * @api private\n\t */\n\tfunction EE(fn, context, once) {\n\t  this.fn = fn;\n\t  this.context = context;\n\t  this.once = once || false;\n\t}\n\t\n\t/**\n\t * Minimal EventEmitter interface that is molded against the Node.js\n\t * EventEmitter interface.\n\t *\n\t * @constructor\n\t * @api public\n\t */\n\tfunction EventEmitter() { /* Nothing to set */ }\n\t\n\t/**\n\t * Holds the assigned EventEmitters by name.\n\t *\n\t * @type {Object}\n\t * @private\n\t */\n\tEventEmitter.prototype._events = undefined;\n\t\n\t/**\n\t * Return a list of assigned event listeners.\n\t *\n\t * @param {String} event The events that should be listed.\n\t * @returns {Array}\n\t * @api public\n\t */\n\tEventEmitter.prototype.listeners = function listeners(event) {\n\t  if (!this._events || !this._events[event]) return [];\n\t  if (this._events[event].fn) return [this._events[event].fn];\n\t\n\t  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {\n\t    ee[i] = this._events[event][i].fn;\n\t  }\n\t\n\t  return ee;\n\t};\n\t\n\t/**\n\t * Emit an event to all registered event listeners.\n\t *\n\t * @param {String} event The name of the event.\n\t * @returns {Boolean} Indication if we've emitted an event.\n\t * @api public\n\t */\n\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t  if (!this._events || !this._events[event]) return false;\n\t\n\t  var listeners = this._events[event]\n\t    , len = arguments.length\n\t    , args\n\t    , i;\n\t\n\t  if ('function' === typeof listeners.fn) {\n\t    if (listeners.once) this.removeListener(event, listeners.fn, true);\n\t\n\t    switch (len) {\n\t      case 1: return listeners.fn.call(listeners.context), true;\n\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t    }\n\t\n\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t      args[i - 1] = arguments[i];\n\t    }\n\t\n\t    listeners.fn.apply(listeners.context, args);\n\t  } else {\n\t    var length = listeners.length\n\t      , j;\n\t\n\t    for (i = 0; i < length; i++) {\n\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);\n\t\n\t      switch (len) {\n\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t        default:\n\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t            args[j - 1] = arguments[j];\n\t          }\n\t\n\t          listeners[i].fn.apply(listeners[i].context, args);\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t/**\n\t * Register a new EventListener for the given event.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Functon} fn Callback function.\n\t * @param {Mixed} context The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t  var listener = new EE(fn, context || this);\n\t\n\t  if (!this._events) this._events = {};\n\t  if (!this._events[event]) this._events[event] = listener;\n\t  else {\n\t    if (!this._events[event].fn) this._events[event].push(listener);\n\t    else this._events[event] = [\n\t      this._events[event], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add an EventListener that's only called once.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Function} fn Callback function.\n\t * @param {Mixed} context The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t  var listener = new EE(fn, context || this, true);\n\t\n\t  if (!this._events) this._events = {};\n\t  if (!this._events[event]) this._events[event] = listener;\n\t  else {\n\t    if (!this._events[event].fn) this._events[event].push(listener);\n\t    else this._events[event] = [\n\t      this._events[event], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove event listeners.\n\t *\n\t * @param {String} event The event we want to remove.\n\t * @param {Function} fn The listener that we need to find.\n\t * @param {Boolean} once Only remove once listeners.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeListener = function removeListener(event, fn, once) {\n\t  if (!this._events || !this._events[event]) return this;\n\t\n\t  var listeners = this._events[event]\n\t    , events = [];\n\t\n\t  if (fn) {\n\t    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {\n\t      events.push(listeners);\n\t    }\n\t    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {\n\t      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {\n\t        events.push(listeners[i]);\n\t      }\n\t    }\n\t  }\n\t\n\t  //\n\t  // Reset the array, or remove it completely if we have no more listeners.\n\t  //\n\t  if (events.length) {\n\t    this._events[event] = events.length === 1 ? events[0] : events;\n\t  } else {\n\t    delete this._events[event];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove all listeners or only the listeners for the specified event.\n\t *\n\t * @param {String} event The event want to remove all listeners for.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t  if (!this._events) return this;\n\t\n\t  if (event) delete this._events[event];\n\t  else this._events = {};\n\t\n\t  return this;\n\t};\n\t\n\t//\n\t// Alias methods names because people roll like that.\n\t//\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t//\n\t// This function doesn't apply anymore.\n\t//\n\tEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n\t  return this;\n\t};\n\t\n\t//\n\t// Expose the module.\n\t//\n\tEventEmitter.EventEmitter = EventEmitter;\n\tEventEmitter.EventEmitter2 = EventEmitter;\n\tEventEmitter.EventEmitter3 = EventEmitter;\n\t\n\t//\n\t// Expose the module.\n\t//\n\tmodule.exports = EventEmitter;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function(window) {\n\t    var re = {\n\t        not_string: /[^s]/,\n\t        number: /[dief]/,\n\t        text: /^[^\\x25]+/,\n\t        modulo: /^\\x25{2}/,\n\t        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fiosuxX])/,\n\t        key: /^([a-z_][a-z_\\d]*)/i,\n\t        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n\t        index_access: /^\\[(\\d+)\\]/,\n\t        sign: /^[\\+\\-]/\n\t    }\n\t\n\t    function sprintf() {\n\t        var key = arguments[0], cache = sprintf.cache\n\t        if (!(cache[key] && cache.hasOwnProperty(key))) {\n\t            cache[key] = sprintf.parse(key)\n\t        }\n\t        return sprintf.format.call(null, cache[key], arguments)\n\t    }\n\t\n\t    sprintf.format = function(parse_tree, argv) {\n\t        var cursor = 1, tree_length = parse_tree.length, node_type = \"\", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = \"\"\n\t        for (i = 0; i < tree_length; i++) {\n\t            node_type = get_type(parse_tree[i])\n\t            if (node_type === \"string\") {\n\t                output[output.length] = parse_tree[i]\n\t            }\n\t            else if (node_type === \"array\") {\n\t                match = parse_tree[i] // convenience purposes only\n\t                if (match[2]) { // keyword argument\n\t                    arg = argv[cursor]\n\t                    for (k = 0; k < match[2].length; k++) {\n\t                        if (!arg.hasOwnProperty(match[2][k])) {\n\t                            throw new Error(sprintf(\"[sprintf] property '%s' does not exist\", match[2][k]))\n\t                        }\n\t                        arg = arg[match[2][k]]\n\t                    }\n\t                }\n\t                else if (match[1]) { // positional argument (explicit)\n\t                    arg = argv[match[1]]\n\t                }\n\t                else { // positional argument (implicit)\n\t                    arg = argv[cursor++]\n\t                }\n\t\n\t                if (get_type(arg) == \"function\") {\n\t                    arg = arg()\n\t                }\n\t\n\t                if (re.not_string.test(match[8]) && (get_type(arg) != \"number\" && isNaN(arg))) {\n\t                    throw new TypeError(sprintf(\"[sprintf] expecting number but found %s\", get_type(arg)))\n\t                }\n\t\n\t                if (re.number.test(match[8])) {\n\t                    is_positive = arg >= 0\n\t                }\n\t\n\t                switch (match[8]) {\n\t                    case \"b\":\n\t                        arg = arg.toString(2)\n\t                    break\n\t                    case \"c\":\n\t                        arg = String.fromCharCode(arg)\n\t                    break\n\t                    case \"d\":\n\t                    case \"i\":\n\t                        arg = parseInt(arg, 10)\n\t                    break\n\t                    case \"e\":\n\t                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()\n\t                    break\n\t                    case \"f\":\n\t                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)\n\t                    break\n\t                    case \"o\":\n\t                        arg = arg.toString(8)\n\t                    break\n\t                    case \"s\":\n\t                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)\n\t                    break\n\t                    case \"u\":\n\t                        arg = arg >>> 0\n\t                    break\n\t                    case \"x\":\n\t                        arg = arg.toString(16)\n\t                    break\n\t                    case \"X\":\n\t                        arg = arg.toString(16).toUpperCase()\n\t                    break\n\t                }\n\t                if (re.number.test(match[8]) && (!is_positive || match[3])) {\n\t                    sign = is_positive ? \"+\" : \"-\"\n\t                    arg = arg.toString().replace(re.sign, \"\")\n\t                }\n\t                else {\n\t                    sign = \"\"\n\t                }\n\t                pad_character = match[4] ? match[4] === \"0\" ? \"0\" : match[4].charAt(1) : \" \"\n\t                pad_length = match[6] - (sign + arg).length\n\t                pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : \"\") : \"\"\n\t                output[output.length] = match[5] ? sign + arg + pad : (pad_character === \"0\" ? sign + pad + arg : pad + sign + arg)\n\t            }\n\t        }\n\t        return output.join(\"\")\n\t    }\n\t\n\t    sprintf.cache = {}\n\t\n\t    sprintf.parse = function(fmt) {\n\t        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0\n\t        while (_fmt) {\n\t            if ((match = re.text.exec(_fmt)) !== null) {\n\t                parse_tree[parse_tree.length] = match[0]\n\t            }\n\t            else if ((match = re.modulo.exec(_fmt)) !== null) {\n\t                parse_tree[parse_tree.length] = \"%\"\n\t            }\n\t            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n\t                if (match[2]) {\n\t                    arg_names |= 1\n\t                    var field_list = [], replacement_field = match[2], field_match = []\n\t                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n\t                        field_list[field_list.length] = field_match[1]\n\t                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== \"\") {\n\t                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n\t                                field_list[field_list.length] = field_match[1]\n\t                            }\n\t                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n\t                                field_list[field_list.length] = field_match[1]\n\t                            }\n\t                            else {\n\t                                throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n\t                            }\n\t                        }\n\t                    }\n\t                    else {\n\t                        throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n\t                    }\n\t                    match[2] = field_list\n\t                }\n\t                else {\n\t                    arg_names |= 2\n\t                }\n\t                if (arg_names === 3) {\n\t                    throw new Error(\"[sprintf] mixing positional and named placeholders is not (yet) supported\")\n\t                }\n\t                parse_tree[parse_tree.length] = match\n\t            }\n\t            else {\n\t                throw new SyntaxError(\"[sprintf] unexpected placeholder\")\n\t            }\n\t            _fmt = _fmt.substring(match[0].length)\n\t        }\n\t        return parse_tree\n\t    }\n\t\n\t    var vsprintf = function(fmt, argv, _argv) {\n\t        _argv = (argv || []).slice(0)\n\t        _argv.splice(0, 0, fmt)\n\t        return sprintf.apply(null, _argv)\n\t    }\n\t\n\t    /**\n\t     * helpers\n\t     */\n\t    function get_type(variable) {\n\t        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()\n\t    }\n\t\n\t    function str_repeat(input, multiplier) {\n\t        return Array(multiplier + 1).join(input)\n\t    }\n\t\n\t    /**\n\t     * export to either browser or node.js\n\t     */\n\t    if (true) {\n\t        exports.sprintf = sprintf\n\t        exports.vsprintf = vsprintf\n\t    }\n\t    else {\n\t        window.sprintf = sprintf\n\t        window.vsprintf = vsprintf\n\t\n\t        if (typeof define === \"function\" && define.amd) {\n\t            define(function() {\n\t                return {\n\t                    sprintf: sprintf,\n\t                    vsprintf: vsprintf\n\t                }\n\t            })\n\t        }\n\t    }\n\t})(typeof window === \"undefined\" ? this : window);\n\n\n/***/ }\n/******/ ])\n});\n\n\n\n/** WEBPACK FOOTER **\n ** translation-dictionary.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1edc99986bde6a99212c\n **/","'use strict';\n\nmodule.exports = require('./lib/translation-dictionary')\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","/*global WITHOUT_EVENTS*/\n'use strict';\n\nif (typeof WITHOUT_EVENTS === 'undefined' || ! WITHOUT_EVENTS)\n    var EventEmitter = require('eventemitter3').EventEmitter3;\nif (typeof WITHOUT_EVENTS === 'undefined' || ! WITHOUT_EVENTS)\n    var inherits     = require('inherits');\nvar sprintf      = require('sprintf-js').sprintf;\nvar vsprintf     = require('sprintf-js').vsprintf;\n\n/**\n * Polyfill\n */\nif ( ! Number.isInteger)\n    Number.isInteger = function(value) {\n        return typeof value === 'number' &&\n            isFinite(value) &&\n            value > -9007199254740992 &&\n            value < 9007199254740992 &&\n            Math.floor(value) === value;\n    };\n\nif ( ! Array.isArray)\n    Array.isArray = function(args) {\n        return Object.prototype.toString.call(args) === '[object Array]';\n    };\n\n/**\n * Defaults\n */\nvar DEFAULT_LOCALE = 'en';\nvar DEFAULT_NPLURALS = 2;\nvar DEFAULT_PLURALIZER = 1;\n\n/**\n * TranslationDictionary\n *\n * @fires changeBaseLocale (locale)               Emitted after baseLocale changed.\n * @fires changeLocale (locale)                   Emitted after locale changed.\n * @fires changeTranslation (locale)              Emitted after translation of the current locale changed.\n * @fires missingPluralTranslation (text, locale) Emitted when the plural text is not found in translation.\n * @fires missingTranslation (text, locale)       Emitted when the text is not found in translation.\n * @fires registerPluralizer (locale, pluralizer) Emitted after a new pluralizer was registered.\n * @fires registerTranslation (locale)            Emitted after a new translation was registered.\n */\nvar TranslationDictionary = function() {\n    this.baseLocale = DEFAULT_LOCALE;\n    this.baseNPlurals = DEFAULT_NPLURALS;\n    this.cache = {}; // cache for current locale\n    this.dict = {};\n    this.locale = DEFAULT_LOCALE;\n    this.nPlurals = {};\n    this.pluralizers = {};\n    this._createDictionary(this.baseLocale);\n};\n\nif (typeof WITHOUT_EVENTS === 'undefined' || ! WITHOUT_EVENTS)\n    inherits(TranslationDictionary, EventEmitter);\n\n/**\n * Get the current locale (default: 'en')\n *\n * @return {string}\n */\nTranslationDictionary.prototype.getLocale = function() {\n    return this.locale;\n};\n\n/**\n * Set a pluralizer for a locale with number of plurals\n *\n * @param {string}       locale       The locale for which to register the pluralizer.\n * @param {callback|int} pluralizer   A callback(number) that returns the index of the plural in dict[text].\n * @param {int}          [nPlurals=2] Number of plurals the language has.\n */\nTranslationDictionary.prototype.registerPluralizer = function(locale, pluralizer, nPlurals) {\n    this.pluralizers[locale] = pluralizer;\n    this.nPlurals[locale] = nPlurals || DEFAULT_NPLURALS;\n    this.cache = {};\n    this.emit('registerPluralizer', locale, pluralizer);\n};\n\n/**\n * Merge translations to a locale\n *\n * @param {string} locale       The locale for which to register the translation.\n * @param {object} translations An Object with the base locale text as key and the translation as value.\n *        {\n *            'wolve' : 'vlk',\n *            'wolves': [ // nPlurals for Czech is 3\n *               'vlci',\n *               'vlků'\n *           ]\n *         }\n */\nTranslationDictionary.prototype.registerTranslation = function(locale, translations) {\n    this._createDictionary(locale);\n\n    // extend / overwrite dict entries\n    for (var text in translations) /*jshint -W089 */\n        this.dict[locale][text] = translations[text];\n\n    this.emit('registerTranslation', locale);\n\n    // emit when translation of the current locale changed\n    if (locale === this.locale && locale !== this.baseLocale)\n        this.emit('changeTranslation', locale);\n};\n\n/**\n * Set the applications base language\n * \n * @param {string} locale   Applications base locale.\n * @param {int}    nPlurals Number of plurals the base locale has.\n */\nTranslationDictionary.prototype.setBaseLocale = function(locale, nPlurals) {\n    this.baseLocale = locale;\n    this.baseNPlurals = nPlurals || DEFAULT_NPLURALS;\n    this._createDictionary(locale); // ensure that an empty dictionary for the locale exists\n    this.emit('changeBaseLocale', locale);\n};\n\n/**\n * Set the current locale\n * \n * @param {string} locale The locale registered before with registerTranslation / application base locale.\n */\nTranslationDictionary.prototype.setLocale = function(locale) {\n    if (locale === this.locale)\n        return;\n    if ( ! this.dict[locale])\n        throw new Error('[dict] setLocale is called for an unregistered translation');\n\n    this.locale = locale;\n    this.cache = {};\n    this.emit('changeLocale', locale);\n};\n\n/**\n * Translate a singular text\n * \n * @param {string} arguments[0]   The text to translate.\n * @param {mixed}  [arguments[n]] Optional parameters for sprintf to replace markers in the text.\n *        Depending on the markers a list of parameters, an array, or an object can be used.\n *        translate('a text');\n *        translate('a text %s %s', 'str1', 'str2');\n *        translate('a text %s %s', [ 'str1', 'str2' ]);\n *        translate('a text %(name)s', { name: 'John Doe' });\n * \n * @return {string} Translated text.\n */\nTranslationDictionary.prototype.translate = function(/*arguments*/) {\n    return this._translate(arguments);\n};\n\n/**\n * Alias for translate()\n */\nTranslationDictionary.prototype.__ = function(/*arguments*/) {\n    return this._translate(arguments);\n};\n\n\n/**\n * Translate a text as singular or plural, depending on the count\n * \n * @param {string} arguments[0]               The singular text to translate.\n * @param {string} arguments[1..(nPlurals-1)] The plural text to translate.\n * @param {mixed}  arguments[nPlurals..n]     The count and parameters for sprintf to replace markers in the text.\n *        Depending on the markers a list of parameters, an array, or an object can be used.\n *        translatePlural('a text', 'some text', 47);\n *        translatePlural('a text %d %s', 'some text %d %s', 47, 'str1');\n *        translatePlural('a text %d %s', 'some text %d %s', [ 47, 'str1' ]);\n *        translatePlural('a text %(name)s', 'some text %(name)s', { count: 47, name: 'John Doe' });\n * \n * @return {string} Translated text.\n */\nTranslationDictionary.prototype.translatePlural = function(/*arguments*/) {\n    return this._translate(arguments, true);\n};\n\n/**\n * Alias for translatePlural()\n */\nTranslationDictionary.prototype._p = function(/*arguments*/) {\n    return this._translate(arguments, true);\n};\n\n/**\n * Translation function called from translate() and translatePlural()\n * \n * @param  {mixed}   args       Arguments from the calling functions.\n * @param  {boolean} withPlural With plural detection.\n * @return {string} Translated text.\n */\nTranslationDictionary.prototype._translate = function(args, withPlural) {\n    // cache\n    var hash = JSON.stringify(arguments);\n    if (hash in this.cache)\n        return this.cache[hash];\n\n    var index = 0;\n    var params; // int / array / object\n    var bnp = this.baseNPlurals;\n    var number;\n\n    if (withPlural) {\n        if (args.length >= bnp) {\n            if (typeof args[bnp - 1] !== 'string')\n                throw new Error('[dict] parameter ' + bnp + ' for plural must be a string for \\'' + args[0] + '\\'');\n\n            params = (args.length > (bnp + 1)) ? Array.prototype.slice.call(args, bnp) : args[bnp];\n\n            if (Number.isInteger(params))\n                number = params;\n            else {\n                if (Array.isArray(params)) {\n                    if ( ! params[0])\n                        throw new Error('[dict] parameter array is empty for \\'' + args[0] + '\\'');\n                    number = params[0];\n                }\n                else if (typeof params === 'object') {\n                    if ( ! params.count)\n                        throw new Error('[dict] numeric object.count is missing for \\'' + args[0] + '\\'');\n                    number = params.count;\n                }\n                if ( ! Number.isInteger(number))\n                    throw new Error('[dict] numeric value is missing for \\'' + args[0] + '\\'');\n            }\n\n            index = this._pluralize(this.baseLocale, number);\n        } else {\n            throw new Error('[dict] plural string and numeric value are missing for \\'' + args[0] + '\\'');\n        }\n    }\n    else {\n        params = (args.length > bnp) ? Array.prototype.slice.call(args, (bnp - 1)) : args[(bnp - 1)];\n    }\n\n    var text = args[index];\n    if (this.locale !== this.baseLocale) {\n        var dictText = this.dict[this.locale][text];\n        if (dictText)\n            if (typeof dictText === 'string') {\n                text = dictText;\n            } else {\n                var localeIndex = this._pluralize(this.locale, number);\n                if (dictText.length >= localeIndex)\n                    text = dictText[localeIndex - 1];\n                else\n                    this.emit('missingPluralTranslation', text, this.locale);\n            }\n        else\n            this.emit('missingTranslation', text, this.locale);\n    }\n\n    if (typeof params !== 'undefined')\n        if (Array.isArray(params))\n            text = vsprintf(text, params);\n        else\n            text = sprintf(text, params);\n\n    this.cache[hash] = text;\n    return text;\n};\n\n/**\n * Create a dictionary if not exists for a locale\n * Set default pluralizer and clear the cache.\n * \n * @param  {string} locale The locale.\n */\nTranslationDictionary.prototype._createDictionary = function(locale) {\n    if ( ! this.dict[locale])\n        this.dict[locale] = {};\n\n    if ( ! this.pluralizers[locale])\n        this.registerPluralizer(locale, DEFAULT_PLURALIZER);\n\n    this.cache = {};\n};\n\n/**\n * Execute the pluralizer\n * \n * @param  {string} locale The locale for which the pluralizer should be used.\n * @param  {int}    number The number to check and get the plural index.\n * @return {int} Index of the plural form in dict[text].\n */\nTranslationDictionary.prototype._pluralize = function(locale, number) {\n    var pluralizer = this.pluralizers[locale];\n    if (typeof pluralizer === 'function')\n        return pluralizer.call(this, number);\n    else\n        return number !== pluralizer ? 1 : 0;\n};\n\nif (typeof WITHOUT_EVENTS === 'undefined' || ! WITHOUT_EVENTS)\n    TranslationDictionary.prototype.emmit = function() { };\n\nmodule.exports = TranslationDictionary;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/translation-dictionary.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  if (!this._events || !this._events[event]) return [];\n  if (this._events[event].fn) return [this._events[event].fn];\n\n  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {\n    ee[i] = this._events[event][i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  if (!this._events || !this._events[event]) return false;\n\n  var listeners = this._events[event]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, once) {\n  if (!this._events || !this._events[event]) return this;\n\n  var listeners = this._events[event]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {\n      events.push(listeners);\n    }\n    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {\n      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {\n        events.push(listeners[i]);\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[event] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[event];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[event];\n  else this._events = {};\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the module.\n//\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.EventEmitter2 = EventEmitter;\nEventEmitter.EventEmitter3 = EventEmitter;\n\n//\n// Expose the module.\n//\nmodule.exports = EventEmitter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/eventemitter3/index.js\n ** module id = 2\n ** module chunks = 0\n **/","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inherits/inherits_browser.js\n ** module id = 3\n ** module chunks = 0\n **/","(function(window) {\n    var re = {\n        not_string: /[^s]/,\n        number: /[dief]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fiosuxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[\\+\\-]/\n    }\n\n    function sprintf() {\n        var key = arguments[0], cache = sprintf.cache\n        if (!(cache[key] && cache.hasOwnProperty(key))) {\n            cache[key] = sprintf.parse(key)\n        }\n        return sprintf.format.call(null, cache[key], arguments)\n    }\n\n    sprintf.format = function(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, node_type = \"\", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = \"\"\n        for (i = 0; i < tree_length; i++) {\n            node_type = get_type(parse_tree[i])\n            if (node_type === \"string\") {\n                output[output.length] = parse_tree[i]\n            }\n            else if (node_type === \"array\") {\n                match = parse_tree[i] // convenience purposes only\n                if (match[2]) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < match[2].length; k++) {\n                        if (!arg.hasOwnProperty(match[2][k])) {\n                            throw new Error(sprintf(\"[sprintf] property '%s' does not exist\", match[2][k]))\n                        }\n                        arg = arg[match[2][k]]\n                    }\n                }\n                else if (match[1]) { // positional argument (explicit)\n                    arg = argv[match[1]]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (get_type(arg) == \"function\") {\n                    arg = arg()\n                }\n\n                if (re.not_string.test(match[8]) && (get_type(arg) != \"number\" && isNaN(arg))) {\n                    throw new TypeError(sprintf(\"[sprintf] expecting number but found %s\", get_type(arg)))\n                }\n\n                if (re.number.test(match[8])) {\n                    is_positive = arg >= 0\n                }\n\n                switch (match[8]) {\n                    case \"b\":\n                        arg = arg.toString(2)\n                    break\n                    case \"c\":\n                        arg = String.fromCharCode(arg)\n                    break\n                    case \"d\":\n                    case \"i\":\n                        arg = parseInt(arg, 10)\n                    break\n                    case \"e\":\n                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()\n                    break\n                    case \"f\":\n                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)\n                    break\n                    case \"o\":\n                        arg = arg.toString(8)\n                    break\n                    case \"s\":\n                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)\n                    break\n                    case \"u\":\n                        arg = arg >>> 0\n                    break\n                    case \"x\":\n                        arg = arg.toString(16)\n                    break\n                    case \"X\":\n                        arg = arg.toString(16).toUpperCase()\n                    break\n                }\n                if (re.number.test(match[8]) && (!is_positive || match[3])) {\n                    sign = is_positive ? \"+\" : \"-\"\n                    arg = arg.toString().replace(re.sign, \"\")\n                }\n                else {\n                    sign = \"\"\n                }\n                pad_character = match[4] ? match[4] === \"0\" ? \"0\" : match[4].charAt(1) : \" \"\n                pad_length = match[6] - (sign + arg).length\n                pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : \"\") : \"\"\n                output[output.length] = match[5] ? sign + arg + pad : (pad_character === \"0\" ? sign + pad + arg : pad + sign + arg)\n            }\n        }\n        return output.join(\"\")\n    }\n\n    sprintf.cache = {}\n\n    sprintf.parse = function(fmt) {\n        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree[parse_tree.length] = match[0]\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree[parse_tree.length] = \"%\"\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list[field_list.length] = field_match[1]\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== \"\") {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list[field_list.length] = field_match[1]\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list[field_list.length] = field_match[1]\n                            }\n                            else {\n                                throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error(\"[sprintf] mixing positional and named placeholders is not (yet) supported\")\n                }\n                parse_tree[parse_tree.length] = match\n            }\n            else {\n                throw new SyntaxError(\"[sprintf] unexpected placeholder\")\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return parse_tree\n    }\n\n    var vsprintf = function(fmt, argv, _argv) {\n        _argv = (argv || []).slice(0)\n        _argv.splice(0, 0, fmt)\n        return sprintf.apply(null, _argv)\n    }\n\n    /**\n     * helpers\n     */\n    function get_type(variable) {\n        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()\n    }\n\n    function str_repeat(input, multiplier) {\n        return Array(multiplier + 1).join(input)\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    if (typeof exports !== \"undefined\") {\n        exports.sprintf = sprintf\n        exports.vsprintf = vsprintf\n    }\n    else {\n        window.sprintf = sprintf\n        window.vsprintf = vsprintf\n\n        if (typeof define === \"function\" && define.amd) {\n            define(function() {\n                return {\n                    sprintf: sprintf,\n                    vsprintf: vsprintf\n                }\n            })\n        }\n    }\n})(typeof window === \"undefined\" ? this : window);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sprintf-js/src/sprintf.js\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"translation-dictionary.min.js"}