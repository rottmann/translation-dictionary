{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///translation-dictionary.woe.min.js","webpack:///webpack/bootstrap 818496acb7e0f4ce1bfe","webpack:///./index.js","webpack:///./lib/translation-dictionary.js","webpack:///./~/sprintf-js/src/sprintf.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","sprintf","vsprintf","Number","isInteger","value","isFinite","Math","floor","Array","isArray","args","Object","prototype","toString","DEFAULT_LOCALE","DEFAULT_NPLURALS","DEFAULT_PLURALIZER","TranslationDictionary","baseLocale","baseNPlurals","cache","dict","locale","nPlurals","pluralizers","_createDictionary","getLocale","registerPluralizer","pluralizer","emit","registerTranslation","translations","text","setBaseLocale","setLocale","Error","translate","_translate","arguments","__","translatePlural","_p","withPlural","hash","JSON","stringify","params","number","index","bnp","length","slice","count","_pluralize","dictText","localeIndex","window","key","hasOwnProperty","parse","format","get_type","variable","toLowerCase","str_repeat","input","multiplier","join","re","not_string","modulo","placeholder","key_access","index_access","sign","parse_tree","argv","arg","i","k","match","pad","pad_character","pad_length","cursor","tree_length","node_type","output","is_positive","test","isNaN","TypeError","String","fromCharCode","parseInt","toExponential","parseFloat","toFixed","substring","toUpperCase","replace","charAt","fmt","_fmt","arg_names","exec","SyntaxError","field_list","replacement_field","field_match","_argv","splice","apply"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TranslationDictionary\"] = factory();\n\telse\n\t\troot[\"TranslationDictionary\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TranslationDictionary\"] = factory();\n\telse\n\t\troot[\"TranslationDictionary\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(1)\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*global WITHOUT_EVENTS*/\n\t'use strict';\n\t\n\tif (false)\n\t    var EventEmitter = require('eventemitter3').EventEmitter3;\n\tif (false)\n\t    var inherits     = require('inherits');\n\tvar sprintf      = __webpack_require__(2).sprintf;\n\tvar vsprintf     = __webpack_require__(2).vsprintf;\n\t\n\t/**\n\t * Polyfill\n\t */\n\tif ( ! Number.isInteger)\n\t    Number.isInteger = function(value) {\n\t        return typeof value === 'number' &&\n\t            isFinite(value) &&\n\t            value > -9007199254740992 &&\n\t            value < 9007199254740992 &&\n\t            Math.floor(value) === value;\n\t    };\n\t\n\tif ( ! Array.isArray)\n\t    Array.isArray = function(args) {\n\t        return Object.prototype.toString.call(args) === '[object Array]';\n\t    };\n\t\n\t/**\n\t * Defaults\n\t */\n\tvar DEFAULT_LOCALE = 'en';\n\tvar DEFAULT_NPLURALS = 2;\n\tvar DEFAULT_PLURALIZER = 1;\n\t\n\t/**\n\t * TranslationDictionary\n\t *\n\t * @fires changeBaseLocale (locale)               Emitted after baseLocale changed.\n\t * @fires changeLocale (locale)                   Emitted after locale changed.\n\t * @fires changeTranslation (locale)              Emitted after translation of the current locale changed.\n\t * @fires missingPluralTranslation (text, locale) Emitted when the plural text is not found in translation.\n\t * @fires missingTranslation (text, locale)       Emitted when the text is not found in translation.\n\t * @fires registerPluralizer (locale, pluralizer) Emitted after a new pluralizer was registered.\n\t * @fires registerTranslation (locale)            Emitted after a new translation was registered.\n\t */\n\tvar TranslationDictionary = function() {\n\t    this.baseLocale = DEFAULT_LOCALE;\n\t    this.baseNPlurals = DEFAULT_NPLURALS;\n\t    this.cache = {}; // cache for current locale\n\t    this.dict = {};\n\t    this.locale = DEFAULT_LOCALE;\n\t    this.nPlurals = {};\n\t    this.pluralizers = {};\n\t    this._createDictionary(this.baseLocale);\n\t};\n\t\n\tif (false)\n\t    inherits(TranslationDictionary, EventEmitter);\n\t\n\t/**\n\t * Get the current locale (default: 'en')\n\t *\n\t * @return {string}\n\t */\n\tTranslationDictionary.prototype.getLocale = function() {\n\t    return this.locale;\n\t};\n\t\n\t/**\n\t * Set a pluralizer for a locale with number of plurals\n\t *\n\t * @param {string}       locale       The locale for which to register the pluralizer.\n\t * @param {callback|int} pluralizer   A callback(number) that returns the index of the plural in dict[text].\n\t * @param {int}          [nPlurals=2] Number of plurals the language has.\n\t */\n\tTranslationDictionary.prototype.registerPluralizer = function(locale, pluralizer, nPlurals) {\n\t    this.pluralizers[locale] = pluralizer;\n\t    this.nPlurals[locale] = nPlurals || DEFAULT_NPLURALS;\n\t    this.cache = {};\n\t    this.emit('registerPluralizer', locale, pluralizer);\n\t};\n\t\n\t/**\n\t * Merge translations to a locale\n\t *\n\t * @param {string} locale       The locale for which to register the translation.\n\t * @param {object} translations An Object with the base locale text as key and the translation as value.\n\t *        {\n\t *            'wolve' : 'vlk',\n\t *            'wolves': [ // nPlurals for Czech is 3\n\t *               'vlci',\n\t *               'vlků'\n\t *           ]\n\t *         }\n\t */\n\tTranslationDictionary.prototype.registerTranslation = function(locale, translations) {\n\t    this._createDictionary(locale);\n\t\n\t    // extend / overwrite dict entries\n\t    for (var text in translations) /*jshint -W089 */\n\t        this.dict[locale][text] = translations[text];\n\t\n\t    this.emit('registerTranslation', locale);\n\t\n\t    // emit when translation of the current locale changed\n\t    if (locale === this.locale && locale !== this.baseLocale)\n\t        this.emit('changeTranslation', locale);\n\t};\n\t\n\t/**\n\t * Set the applications base language\n\t * \n\t * @param {string} locale   Applications base locale.\n\t * @param {int}    nPlurals Number of plurals the base locale has.\n\t */\n\tTranslationDictionary.prototype.setBaseLocale = function(locale, nPlurals) {\n\t    this.baseLocale = locale;\n\t    this.baseNPlurals = nPlurals || DEFAULT_NPLURALS;\n\t    this._createDictionary(locale); // ensure that an empty dictionary for the locale exists\n\t    this.emit('changeBaseLocale', locale);\n\t};\n\t\n\t/**\n\t * Set the current locale\n\t * \n\t * @param {string} locale The locale registered before with registerTranslation / application base locale.\n\t */\n\tTranslationDictionary.prototype.setLocale = function(locale) {\n\t    if (locale === this.locale)\n\t        return;\n\t    if ( ! this.dict[locale])\n\t        throw new Error('[dict] setLocale is called for an unregistered translation');\n\t\n\t    this.locale = locale;\n\t    this.cache = {};\n\t    this.emit('changeLocale', locale);\n\t};\n\t\n\t/**\n\t * Translate a singular text\n\t * \n\t * @param {string} arguments[0]   The text to translate.\n\t * @param {mixed}  [arguments[n]] Optional parameters for sprintf to replace markers in the text.\n\t *        Depending on the markers a list of parameters, an array, or an object can be used.\n\t *        translate('a text');\n\t *        translate('a text %s %s', 'str1', 'str2');\n\t *        translate('a text %s %s', [ 'str1', 'str2' ]);\n\t *        translate('a text %(name)s', { name: 'John Doe' });\n\t * \n\t * @return {string} Translated text.\n\t */\n\tTranslationDictionary.prototype.translate = function(/*arguments*/) {\n\t    return this._translate(arguments);\n\t};\n\t\n\t/**\n\t * Alias for translate()\n\t */\n\tTranslationDictionary.prototype.__ = function(/*arguments*/) {\n\t    return this._translate(arguments);\n\t};\n\t\n\t\n\t/**\n\t * Translate a text as singular or plural, depending on the count\n\t * \n\t * @param {string} arguments[0]               The singular text to translate.\n\t * @param {string} arguments[1..(nPlurals-1)] The plural text to translate.\n\t * @param {mixed}  arguments[nPlurals..n]     The count and parameters for sprintf to replace markers in the text.\n\t *        Depending on the markers a list of parameters, an array, or an object can be used.\n\t *        translatePlural('a text', 'some text', 47);\n\t *        translatePlural('a text %d %s', 'some text %d %s', 47, 'str1');\n\t *        translatePlural('a text %d %s', 'some text %d %s', [ 47, 'str1' ]);\n\t *        translatePlural('a text %(name)s', 'some text %(name)s', { count: 47, name: 'John Doe' });\n\t * \n\t * @return {string} Translated text.\n\t */\n\tTranslationDictionary.prototype.translatePlural = function(/*arguments*/) {\n\t    return this._translate(arguments, true);\n\t};\n\t\n\t/**\n\t * Alias for translatePlural()\n\t */\n\tTranslationDictionary.prototype._p = function(/*arguments*/) {\n\t    return this._translate(arguments, true);\n\t};\n\t\n\t/**\n\t * Translation function called from translate() and translatePlural()\n\t * \n\t * @param  {mixed}   args       Arguments from the calling functions.\n\t * @param  {boolean} withPlural With plural detection.\n\t * @return {string} Translated text.\n\t */\n\tTranslationDictionary.prototype._translate = function(args, withPlural) {\n\t    // cache\n\t    var hash = JSON.stringify(arguments);\n\t    if (hash in this.cache)\n\t        return this.cache[hash];\n\t\n\t    var index = 0;\n\t    var params; // int / array / object\n\t    var bnp = this.baseNPlurals;\n\t    var number;\n\t\n\t    if (withPlural) {\n\t        if (args.length >= bnp) {\n\t            if (typeof args[bnp - 1] !== 'string')\n\t                throw new Error('[dict] parameter ' + bnp + ' for plural must be a string for \\'' + args[0] + '\\'');\n\t\n\t            params = (args.length > (bnp + 1)) ? Array.prototype.slice.call(args, bnp) : args[bnp];\n\t\n\t            if (Number.isInteger(params))\n\t                number = params;\n\t            else {\n\t                if (Array.isArray(params)) {\n\t                    if ( ! params[0])\n\t                        throw new Error('[dict] parameter array is empty for \\'' + args[0] + '\\'');\n\t                    number = params[0];\n\t                }\n\t                else if (typeof params === 'object') {\n\t                    if ( ! params.count)\n\t                        throw new Error('[dict] numeric object.count is missing for \\'' + args[0] + '\\'');\n\t                    number = params.count;\n\t                }\n\t                if ( ! Number.isInteger(number))\n\t                    throw new Error('[dict] numeric value is missing for \\'' + args[0] + '\\'');\n\t            }\n\t\n\t            index = this._pluralize(this.baseLocale, number);\n\t        } else {\n\t            throw new Error('[dict] plural string and numeric value are missing for \\'' + args[0] + '\\'');\n\t        }\n\t    }\n\t    else {\n\t        params = (args.length > bnp) ? Array.prototype.slice.call(args, (bnp - 1)) : args[(bnp - 1)];\n\t    }\n\t\n\t    var text = args[index];\n\t    if (this.locale !== this.baseLocale) {\n\t        var dictText = this.dict[this.locale][text];\n\t        if (dictText)\n\t            if (typeof dictText === 'string') {\n\t                text = dictText;\n\t            } else {\n\t                var localeIndex = this._pluralize(this.locale, number);\n\t                if (dictText.length >= localeIndex)\n\t                    text = dictText[localeIndex - 1];\n\t                else\n\t                    this.emit('missingPluralTranslation', text, this.locale);\n\t            }\n\t        else\n\t            this.emit('missingTranslation', text, this.locale);\n\t    }\n\t\n\t    if (typeof params !== 'undefined')\n\t        if (Array.isArray(params))\n\t            text = vsprintf(text, params);\n\t        else\n\t            text = sprintf(text, params);\n\t\n\t    this.cache[hash] = text;\n\t    return text;\n\t};\n\t\n\t/**\n\t * Create a dictionary if not exists for a locale\n\t * Set default pluralizer and clear the cache.\n\t * \n\t * @param  {string} locale The locale.\n\t */\n\tTranslationDictionary.prototype._createDictionary = function(locale) {\n\t    if ( ! this.dict[locale])\n\t        this.dict[locale] = {};\n\t\n\t    if ( ! this.pluralizers[locale])\n\t        this.registerPluralizer(locale, DEFAULT_PLURALIZER);\n\t\n\t    this.cache = {};\n\t};\n\t\n\t/**\n\t * Execute the pluralizer\n\t * \n\t * @param  {string} locale The locale for which the pluralizer should be used.\n\t * @param  {int}    number The number to check and get the plural index.\n\t * @return {int} Index of the plural form in dict[text].\n\t */\n\tTranslationDictionary.prototype._pluralize = function(locale, number) {\n\t    var pluralizer = this.pluralizers[locale];\n\t    if (typeof pluralizer === 'function')\n\t        return pluralizer.call(this, number);\n\t    else\n\t        return number !== pluralizer ? 1 : 0;\n\t};\n\t\n\tif (false)\n\t    TranslationDictionary.prototype.emmit = function() { };\n\t\n\tmodule.exports = TranslationDictionary;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function(window) {\n\t    var re = {\n\t        not_string: /[^s]/,\n\t        number: /[dief]/,\n\t        text: /^[^\\x25]+/,\n\t        modulo: /^\\x25{2}/,\n\t        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fiosuxX])/,\n\t        key: /^([a-z_][a-z_\\d]*)/i,\n\t        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n\t        index_access: /^\\[(\\d+)\\]/,\n\t        sign: /^[\\+\\-]/\n\t    }\n\t\n\t    function sprintf() {\n\t        var key = arguments[0], cache = sprintf.cache\n\t        if (!(cache[key] && cache.hasOwnProperty(key))) {\n\t            cache[key] = sprintf.parse(key)\n\t        }\n\t        return sprintf.format.call(null, cache[key], arguments)\n\t    }\n\t\n\t    sprintf.format = function(parse_tree, argv) {\n\t        var cursor = 1, tree_length = parse_tree.length, node_type = \"\", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = \"\"\n\t        for (i = 0; i < tree_length; i++) {\n\t            node_type = get_type(parse_tree[i])\n\t            if (node_type === \"string\") {\n\t                output[output.length] = parse_tree[i]\n\t            }\n\t            else if (node_type === \"array\") {\n\t                match = parse_tree[i] // convenience purposes only\n\t                if (match[2]) { // keyword argument\n\t                    arg = argv[cursor]\n\t                    for (k = 0; k < match[2].length; k++) {\n\t                        if (!arg.hasOwnProperty(match[2][k])) {\n\t                            throw new Error(sprintf(\"[sprintf] property '%s' does not exist\", match[2][k]))\n\t                        }\n\t                        arg = arg[match[2][k]]\n\t                    }\n\t                }\n\t                else if (match[1]) { // positional argument (explicit)\n\t                    arg = argv[match[1]]\n\t                }\n\t                else { // positional argument (implicit)\n\t                    arg = argv[cursor++]\n\t                }\n\t\n\t                if (get_type(arg) == \"function\") {\n\t                    arg = arg()\n\t                }\n\t\n\t                if (re.not_string.test(match[8]) && (get_type(arg) != \"number\" && isNaN(arg))) {\n\t                    throw new TypeError(sprintf(\"[sprintf] expecting number but found %s\", get_type(arg)))\n\t                }\n\t\n\t                if (re.number.test(match[8])) {\n\t                    is_positive = arg >= 0\n\t                }\n\t\n\t                switch (match[8]) {\n\t                    case \"b\":\n\t                        arg = arg.toString(2)\n\t                    break\n\t                    case \"c\":\n\t                        arg = String.fromCharCode(arg)\n\t                    break\n\t                    case \"d\":\n\t                    case \"i\":\n\t                        arg = parseInt(arg, 10)\n\t                    break\n\t                    case \"e\":\n\t                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()\n\t                    break\n\t                    case \"f\":\n\t                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)\n\t                    break\n\t                    case \"o\":\n\t                        arg = arg.toString(8)\n\t                    break\n\t                    case \"s\":\n\t                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)\n\t                    break\n\t                    case \"u\":\n\t                        arg = arg >>> 0\n\t                    break\n\t                    case \"x\":\n\t                        arg = arg.toString(16)\n\t                    break\n\t                    case \"X\":\n\t                        arg = arg.toString(16).toUpperCase()\n\t                    break\n\t                }\n\t                if (re.number.test(match[8]) && (!is_positive || match[3])) {\n\t                    sign = is_positive ? \"+\" : \"-\"\n\t                    arg = arg.toString().replace(re.sign, \"\")\n\t                }\n\t                else {\n\t                    sign = \"\"\n\t                }\n\t                pad_character = match[4] ? match[4] === \"0\" ? \"0\" : match[4].charAt(1) : \" \"\n\t                pad_length = match[6] - (sign + arg).length\n\t                pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : \"\") : \"\"\n\t                output[output.length] = match[5] ? sign + arg + pad : (pad_character === \"0\" ? sign + pad + arg : pad + sign + arg)\n\t            }\n\t        }\n\t        return output.join(\"\")\n\t    }\n\t\n\t    sprintf.cache = {}\n\t\n\t    sprintf.parse = function(fmt) {\n\t        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0\n\t        while (_fmt) {\n\t            if ((match = re.text.exec(_fmt)) !== null) {\n\t                parse_tree[parse_tree.length] = match[0]\n\t            }\n\t            else if ((match = re.modulo.exec(_fmt)) !== null) {\n\t                parse_tree[parse_tree.length] = \"%\"\n\t            }\n\t            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n\t                if (match[2]) {\n\t                    arg_names |= 1\n\t                    var field_list = [], replacement_field = match[2], field_match = []\n\t                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n\t                        field_list[field_list.length] = field_match[1]\n\t                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== \"\") {\n\t                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n\t                                field_list[field_list.length] = field_match[1]\n\t                            }\n\t                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n\t                                field_list[field_list.length] = field_match[1]\n\t                            }\n\t                            else {\n\t                                throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n\t                            }\n\t                        }\n\t                    }\n\t                    else {\n\t                        throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n\t                    }\n\t                    match[2] = field_list\n\t                }\n\t                else {\n\t                    arg_names |= 2\n\t                }\n\t                if (arg_names === 3) {\n\t                    throw new Error(\"[sprintf] mixing positional and named placeholders is not (yet) supported\")\n\t                }\n\t                parse_tree[parse_tree.length] = match\n\t            }\n\t            else {\n\t                throw new SyntaxError(\"[sprintf] unexpected placeholder\")\n\t            }\n\t            _fmt = _fmt.substring(match[0].length)\n\t        }\n\t        return parse_tree\n\t    }\n\t\n\t    var vsprintf = function(fmt, argv, _argv) {\n\t        _argv = (argv || []).slice(0)\n\t        _argv.splice(0, 0, fmt)\n\t        return sprintf.apply(null, _argv)\n\t    }\n\t\n\t    /**\n\t     * helpers\n\t     */\n\t    function get_type(variable) {\n\t        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()\n\t    }\n\t\n\t    function str_repeat(input, multiplier) {\n\t        return Array(multiplier + 1).join(input)\n\t    }\n\t\n\t    /**\n\t     * export to either browser or node.js\n\t     */\n\t    if (true) {\n\t        exports.sprintf = sprintf\n\t        exports.vsprintf = vsprintf\n\t    }\n\t    else {\n\t        window.sprintf = sprintf\n\t        window.vsprintf = vsprintf\n\t\n\t        if (typeof define === \"function\" && define.amd) {\n\t            define(function() {\n\t                return {\n\t                    sprintf: sprintf,\n\t                    vsprintf: vsprintf\n\t                }\n\t            })\n\t        }\n\t    }\n\t})(typeof window === \"undefined\" ? this : window);\n\n\n/***/ }\n/******/ ])\n});\n\n\n\n/** WEBPACK FOOTER **\n ** translation-dictionary.woe.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 818496acb7e0f4ce1bfe\n **/","'use strict';\n\nmodule.exports = require('./lib/translation-dictionary')\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","/*global WITHOUT_EVENTS*/\n'use strict';\n\nif (typeof WITHOUT_EVENTS === 'undefined' || ! WITHOUT_EVENTS)\n    var EventEmitter = require('eventemitter3').EventEmitter3;\nif (typeof WITHOUT_EVENTS === 'undefined' || ! WITHOUT_EVENTS)\n    var inherits     = require('inherits');\nvar sprintf      = require('sprintf-js').sprintf;\nvar vsprintf     = require('sprintf-js').vsprintf;\n\n/**\n * Polyfill\n */\nif ( ! Number.isInteger)\n    Number.isInteger = function(value) {\n        return typeof value === 'number' &&\n            isFinite(value) &&\n            value > -9007199254740992 &&\n            value < 9007199254740992 &&\n            Math.floor(value) === value;\n    };\n\nif ( ! Array.isArray)\n    Array.isArray = function(args) {\n        return Object.prototype.toString.call(args) === '[object Array]';\n    };\n\n/**\n * Defaults\n */\nvar DEFAULT_LOCALE = 'en';\nvar DEFAULT_NPLURALS = 2;\nvar DEFAULT_PLURALIZER = 1;\n\n/**\n * TranslationDictionary\n *\n * @fires changeBaseLocale (locale)               Emitted after baseLocale changed.\n * @fires changeLocale (locale)                   Emitted after locale changed.\n * @fires changeTranslation (locale)              Emitted after translation of the current locale changed.\n * @fires missingPluralTranslation (text, locale) Emitted when the plural text is not found in translation.\n * @fires missingTranslation (text, locale)       Emitted when the text is not found in translation.\n * @fires registerPluralizer (locale, pluralizer) Emitted after a new pluralizer was registered.\n * @fires registerTranslation (locale)            Emitted after a new translation was registered.\n */\nvar TranslationDictionary = function() {\n    this.baseLocale = DEFAULT_LOCALE;\n    this.baseNPlurals = DEFAULT_NPLURALS;\n    this.cache = {}; // cache for current locale\n    this.dict = {};\n    this.locale = DEFAULT_LOCALE;\n    this.nPlurals = {};\n    this.pluralizers = {};\n    this._createDictionary(this.baseLocale);\n};\n\nif (typeof WITHOUT_EVENTS === 'undefined' || ! WITHOUT_EVENTS)\n    inherits(TranslationDictionary, EventEmitter);\n\n/**\n * Get the current locale (default: 'en')\n *\n * @return {string}\n */\nTranslationDictionary.prototype.getLocale = function() {\n    return this.locale;\n};\n\n/**\n * Set a pluralizer for a locale with number of plurals\n *\n * @param {string}       locale       The locale for which to register the pluralizer.\n * @param {callback|int} pluralizer   A callback(number) that returns the index of the plural in dict[text].\n * @param {int}          [nPlurals=2] Number of plurals the language has.\n */\nTranslationDictionary.prototype.registerPluralizer = function(locale, pluralizer, nPlurals) {\n    this.pluralizers[locale] = pluralizer;\n    this.nPlurals[locale] = nPlurals || DEFAULT_NPLURALS;\n    this.cache = {};\n    this.emit('registerPluralizer', locale, pluralizer);\n};\n\n/**\n * Merge translations to a locale\n *\n * @param {string} locale       The locale for which to register the translation.\n * @param {object} translations An Object with the base locale text as key and the translation as value.\n *        {\n *            'wolve' : 'vlk',\n *            'wolves': [ // nPlurals for Czech is 3\n *               'vlci',\n *               'vlků'\n *           ]\n *         }\n */\nTranslationDictionary.prototype.registerTranslation = function(locale, translations) {\n    this._createDictionary(locale);\n\n    // extend / overwrite dict entries\n    for (var text in translations) /*jshint -W089 */\n        this.dict[locale][text] = translations[text];\n\n    this.emit('registerTranslation', locale);\n\n    // emit when translation of the current locale changed\n    if (locale === this.locale && locale !== this.baseLocale)\n        this.emit('changeTranslation', locale);\n};\n\n/**\n * Set the applications base language\n * \n * @param {string} locale   Applications base locale.\n * @param {int}    nPlurals Number of plurals the base locale has.\n */\nTranslationDictionary.prototype.setBaseLocale = function(locale, nPlurals) {\n    this.baseLocale = locale;\n    this.baseNPlurals = nPlurals || DEFAULT_NPLURALS;\n    this._createDictionary(locale); // ensure that an empty dictionary for the locale exists\n    this.emit('changeBaseLocale', locale);\n};\n\n/**\n * Set the current locale\n * \n * @param {string} locale The locale registered before with registerTranslation / application base locale.\n */\nTranslationDictionary.prototype.setLocale = function(locale) {\n    if (locale === this.locale)\n        return;\n    if ( ! this.dict[locale])\n        throw new Error('[dict] setLocale is called for an unregistered translation');\n\n    this.locale = locale;\n    this.cache = {};\n    this.emit('changeLocale', locale);\n};\n\n/**\n * Translate a singular text\n * \n * @param {string} arguments[0]   The text to translate.\n * @param {mixed}  [arguments[n]] Optional parameters for sprintf to replace markers in the text.\n *        Depending on the markers a list of parameters, an array, or an object can be used.\n *        translate('a text');\n *        translate('a text %s %s', 'str1', 'str2');\n *        translate('a text %s %s', [ 'str1', 'str2' ]);\n *        translate('a text %(name)s', { name: 'John Doe' });\n * \n * @return {string} Translated text.\n */\nTranslationDictionary.prototype.translate = function(/*arguments*/) {\n    return this._translate(arguments);\n};\n\n/**\n * Alias for translate()\n */\nTranslationDictionary.prototype.__ = function(/*arguments*/) {\n    return this._translate(arguments);\n};\n\n\n/**\n * Translate a text as singular or plural, depending on the count\n * \n * @param {string} arguments[0]               The singular text to translate.\n * @param {string} arguments[1..(nPlurals-1)] The plural text to translate.\n * @param {mixed}  arguments[nPlurals..n]     The count and parameters for sprintf to replace markers in the text.\n *        Depending on the markers a list of parameters, an array, or an object can be used.\n *        translatePlural('a text', 'some text', 47);\n *        translatePlural('a text %d %s', 'some text %d %s', 47, 'str1');\n *        translatePlural('a text %d %s', 'some text %d %s', [ 47, 'str1' ]);\n *        translatePlural('a text %(name)s', 'some text %(name)s', { count: 47, name: 'John Doe' });\n * \n * @return {string} Translated text.\n */\nTranslationDictionary.prototype.translatePlural = function(/*arguments*/) {\n    return this._translate(arguments, true);\n};\n\n/**\n * Alias for translatePlural()\n */\nTranslationDictionary.prototype._p = function(/*arguments*/) {\n    return this._translate(arguments, true);\n};\n\n/**\n * Translation function called from translate() and translatePlural()\n * \n * @param  {mixed}   args       Arguments from the calling functions.\n * @param  {boolean} withPlural With plural detection.\n * @return {string} Translated text.\n */\nTranslationDictionary.prototype._translate = function(args, withPlural) {\n    // cache\n    var hash = JSON.stringify(arguments);\n    if (hash in this.cache)\n        return this.cache[hash];\n\n    var index = 0;\n    var params; // int / array / object\n    var bnp = this.baseNPlurals;\n    var number;\n\n    if (withPlural) {\n        if (args.length >= bnp) {\n            if (typeof args[bnp - 1] !== 'string')\n                throw new Error('[dict] parameter ' + bnp + ' for plural must be a string for \\'' + args[0] + '\\'');\n\n            params = (args.length > (bnp + 1)) ? Array.prototype.slice.call(args, bnp) : args[bnp];\n\n            if (Number.isInteger(params))\n                number = params;\n            else {\n                if (Array.isArray(params)) {\n                    if ( ! params[0])\n                        throw new Error('[dict] parameter array is empty for \\'' + args[0] + '\\'');\n                    number = params[0];\n                }\n                else if (typeof params === 'object') {\n                    if ( ! params.count)\n                        throw new Error('[dict] numeric object.count is missing for \\'' + args[0] + '\\'');\n                    number = params.count;\n                }\n                if ( ! Number.isInteger(number))\n                    throw new Error('[dict] numeric value is missing for \\'' + args[0] + '\\'');\n            }\n\n            index = this._pluralize(this.baseLocale, number);\n        } else {\n            throw new Error('[dict] plural string and numeric value are missing for \\'' + args[0] + '\\'');\n        }\n    }\n    else {\n        params = (args.length > bnp) ? Array.prototype.slice.call(args, (bnp - 1)) : args[(bnp - 1)];\n    }\n\n    var text = args[index];\n    if (this.locale !== this.baseLocale) {\n        var dictText = this.dict[this.locale][text];\n        if (dictText)\n            if (typeof dictText === 'string') {\n                text = dictText;\n            } else {\n                var localeIndex = this._pluralize(this.locale, number);\n                if (dictText.length >= localeIndex)\n                    text = dictText[localeIndex - 1];\n                else\n                    this.emit('missingPluralTranslation', text, this.locale);\n            }\n        else\n            this.emit('missingTranslation', text, this.locale);\n    }\n\n    if (typeof params !== 'undefined')\n        if (Array.isArray(params))\n            text = vsprintf(text, params);\n        else\n            text = sprintf(text, params);\n\n    this.cache[hash] = text;\n    return text;\n};\n\n/**\n * Create a dictionary if not exists for a locale\n * Set default pluralizer and clear the cache.\n * \n * @param  {string} locale The locale.\n */\nTranslationDictionary.prototype._createDictionary = function(locale) {\n    if ( ! this.dict[locale])\n        this.dict[locale] = {};\n\n    if ( ! this.pluralizers[locale])\n        this.registerPluralizer(locale, DEFAULT_PLURALIZER);\n\n    this.cache = {};\n};\n\n/**\n * Execute the pluralizer\n * \n * @param  {string} locale The locale for which the pluralizer should be used.\n * @param  {int}    number The number to check and get the plural index.\n * @return {int} Index of the plural form in dict[text].\n */\nTranslationDictionary.prototype._pluralize = function(locale, number) {\n    var pluralizer = this.pluralizers[locale];\n    if (typeof pluralizer === 'function')\n        return pluralizer.call(this, number);\n    else\n        return number !== pluralizer ? 1 : 0;\n};\n\nif (typeof WITHOUT_EVENTS === 'undefined' || ! WITHOUT_EVENTS)\n    TranslationDictionary.prototype.emmit = function() { };\n\nmodule.exports = TranslationDictionary;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/translation-dictionary.js\n ** module id = 1\n ** module chunks = 0\n **/","(function(window) {\n    var re = {\n        not_string: /[^s]/,\n        number: /[dief]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fiosuxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[\\+\\-]/\n    }\n\n    function sprintf() {\n        var key = arguments[0], cache = sprintf.cache\n        if (!(cache[key] && cache.hasOwnProperty(key))) {\n            cache[key] = sprintf.parse(key)\n        }\n        return sprintf.format.call(null, cache[key], arguments)\n    }\n\n    sprintf.format = function(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, node_type = \"\", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = \"\"\n        for (i = 0; i < tree_length; i++) {\n            node_type = get_type(parse_tree[i])\n            if (node_type === \"string\") {\n                output[output.length] = parse_tree[i]\n            }\n            else if (node_type === \"array\") {\n                match = parse_tree[i] // convenience purposes only\n                if (match[2]) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < match[2].length; k++) {\n                        if (!arg.hasOwnProperty(match[2][k])) {\n                            throw new Error(sprintf(\"[sprintf] property '%s' does not exist\", match[2][k]))\n                        }\n                        arg = arg[match[2][k]]\n                    }\n                }\n                else if (match[1]) { // positional argument (explicit)\n                    arg = argv[match[1]]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (get_type(arg) == \"function\") {\n                    arg = arg()\n                }\n\n                if (re.not_string.test(match[8]) && (get_type(arg) != \"number\" && isNaN(arg))) {\n                    throw new TypeError(sprintf(\"[sprintf] expecting number but found %s\", get_type(arg)))\n                }\n\n                if (re.number.test(match[8])) {\n                    is_positive = arg >= 0\n                }\n\n                switch (match[8]) {\n                    case \"b\":\n                        arg = arg.toString(2)\n                    break\n                    case \"c\":\n                        arg = String.fromCharCode(arg)\n                    break\n                    case \"d\":\n                    case \"i\":\n                        arg = parseInt(arg, 10)\n                    break\n                    case \"e\":\n                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()\n                    break\n                    case \"f\":\n                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)\n                    break\n                    case \"o\":\n                        arg = arg.toString(8)\n                    break\n                    case \"s\":\n                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)\n                    break\n                    case \"u\":\n                        arg = arg >>> 0\n                    break\n                    case \"x\":\n                        arg = arg.toString(16)\n                    break\n                    case \"X\":\n                        arg = arg.toString(16).toUpperCase()\n                    break\n                }\n                if (re.number.test(match[8]) && (!is_positive || match[3])) {\n                    sign = is_positive ? \"+\" : \"-\"\n                    arg = arg.toString().replace(re.sign, \"\")\n                }\n                else {\n                    sign = \"\"\n                }\n                pad_character = match[4] ? match[4] === \"0\" ? \"0\" : match[4].charAt(1) : \" \"\n                pad_length = match[6] - (sign + arg).length\n                pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : \"\") : \"\"\n                output[output.length] = match[5] ? sign + arg + pad : (pad_character === \"0\" ? sign + pad + arg : pad + sign + arg)\n            }\n        }\n        return output.join(\"\")\n    }\n\n    sprintf.cache = {}\n\n    sprintf.parse = function(fmt) {\n        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree[parse_tree.length] = match[0]\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree[parse_tree.length] = \"%\"\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list[field_list.length] = field_match[1]\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== \"\") {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list[field_list.length] = field_match[1]\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list[field_list.length] = field_match[1]\n                            }\n                            else {\n                                throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error(\"[sprintf] mixing positional and named placeholders is not (yet) supported\")\n                }\n                parse_tree[parse_tree.length] = match\n            }\n            else {\n                throw new SyntaxError(\"[sprintf] unexpected placeholder\")\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return parse_tree\n    }\n\n    var vsprintf = function(fmt, argv, _argv) {\n        _argv = (argv || []).slice(0)\n        _argv.splice(0, 0, fmt)\n        return sprintf.apply(null, _argv)\n    }\n\n    /**\n     * helpers\n     */\n    function get_type(variable) {\n        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()\n    }\n\n    function str_repeat(input, multiplier) {\n        return Array(multiplier + 1).join(input)\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    if (typeof exports !== \"undefined\") {\n        exports.sprintf = sprintf\n        exports.vsprintf = vsprintf\n    }\n    else {\n        window.sprintf = sprintf\n        window.vsprintf = vsprintf\n\n        if (typeof define === \"function\" && define.amd) {\n            define(function() {\n                return {\n                    sprintf: sprintf,\n                    vsprintf: vsprintf\n                }\n            })\n        }\n    }\n})(typeof window === \"undefined\" ? this : window);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/sprintf-js/src/sprintf.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"translation-dictionary.woe.min.js"}